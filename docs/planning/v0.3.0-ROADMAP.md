# v0.3.0 Roadmap - "Next-Generation Terminal Graphics"

**Status**: ‚úÖ Finalized & Approved  
**Created**: November 5, 2025  
**Approved**: November 5, 2025  
**Target Release**: 8-10 weeks (mid-January 2026)  
**Focus**: Scene-based patterns (5 scenes) + Metaball Playground

---

## üéØ Vision

Transform ascii-splash from an **abstract animation engine** into a **living environment simulator** that makes developers say:

> **"WHOA, that's running in a TERMINAL?!"**

**Core Philosophy**: Move beyond abstract effects (plasma, waves, spirals) to create **recognizable, living scenes** (beaches, forests, aquariums) while maintaining our performance standards (4-6% CPU, 60 FPS).

---

## ‚úÖ Finalized Scope

**Confirmed Features**:
- ‚úÖ **All 5 scene-based patterns**: Ocean Beach, Campfire, Aquarium, Night Sky, Snowfall
- ‚úÖ **1 advanced effect**: Metaball Playground (interactive liquid physics)
- ‚úÖ **New architecture**: Scene graph, sprite system, enhanced particles
- ‚úÖ **Performance targets**: 4-6% CPU per scene (variable by complexity)
- ‚úÖ **Wildlife scope**: Fish for Aquarium, seagulls for Beach (minimal)
- ‚úÖ **Dependencies**: Add `simplex-noise` for organic motion
- ‚úÖ **User control**: Presets only (6 per scene), parameters deferred to v0.4.0
- ‚úÖ **Timeline**: 8-10 weeks total, 4 phases

**Deferred to v0.4.0+**:
- ‚ùå Fluid dynamics (too complex for v0.3.0)
- ‚ùå Ray-marched 3D scenes (performance concerns)
- ‚ùå Additional wildlife (squirrels, insects, etc.)
- ‚ùå Exposed scene parameters (fish count, wave speed, etc.)
- ‚ùå ASCII art morphing

---

## üìä Current State (v0.2.0)

### What We Have
- ‚úÖ **17 excellent patterns** (9 rated "Excellent", 5 "Very Good", 3 "Good")
- ‚úÖ **Strong technical foundation** (60 FPS, <5% CPU, RGB colors, mouse interaction)
- ‚úÖ **Sophisticated effects** (multi-level branching, multi-stage explosions, 3D tunnel rendering)
- ‚úÖ **Published to npm** with comprehensive documentation
- ‚úÖ **Existing utilities**: metaballs, noise generation, particle systems, Bresenham lines

### Current Pattern Categories
**Abstract Effects** (11): Wave, Plasma, Tunnel, Spiral, Quicksilver, Rain, Snow, Smoke, Matrix, Lightning, Fireworks  
**Physics Simulations** (3): Particle, Life, Maze  
**Organic Forms** (3): DNA, LavaLamp, Starfield

### Gap Analysis
- ‚ùå **No scene-based patterns** (environments that tell a story)
- ‚ùå **No boid/flocking behaviors** (organic group movement)
- ‚ùå **No accumulation/state persistence** (footprints, puddles, snow buildup)
- ‚ùå **No layered scene graphs** (foreground/midground/background)
- ‚ö†Ô∏è **Limited interactivity depth** (mostly click/hover, not "living" reactions)

---

## üé® Three Strategic Directions

We've identified three potential focuses for v0.3.0:

### Option 1: Scene-Based Patterns üåäüå≤üî• (RECOMMENDED)
**Move beyond abstract effects to living, breathing environments**

**Advantages**:
- ‚úÖ Unique differentiator (no other terminal animation app does this)
- ‚úÖ Perfect for ambient IDE backgrounds (our core use case)
- ‚úÖ High emotional engagement (nature, fire, aquariums are universally appealing)
- ‚úÖ Great for demos/marketing (immediate visual recognition)
- ‚úÖ Builds on our existing strengths (particles, colors, interactivity)

**Challenges**:
- ‚ö†Ô∏è More complex than abstract patterns (multiple systems per scene)
- ‚ö†Ô∏è Requires new architecture (scene graphs, layers, sprites)
- ‚ö†Ô∏è Performance tuning needed (many animated elements)

**Top 5 Scene Candidates** (see detailed specs below):
1. **Ocean Beach** - Rolling waves, seagulls, clouds, sun sparkles
2. **Aquarium** - Fish schools (boids), swaying plants, bubbles
3. **Campfire** - Flickering flames, rising sparks, smoke
4. **Night Sky with Aurora** - Stars, aurora ribbons, meteors
5. **Snowfall in Park** - Falling snow, accumulation, swaying trees

---

### Option 2: Advanced Visual Effects üé®‚ú®
**Push technical boundaries with cutting-edge rendering techniques**

**Advantages**:
- ‚úÖ "WHOA" factor (technical showcase)
- ‚úÖ Attracts demoscene/graphics enthusiasts
- ‚úÖ Groundbreaking (fluid sim, ray-marching in terminals)

**Challenges**:
- ‚ö†Ô∏è Very high complexity (may require Web Workers)
- ‚ö†Ô∏è Performance challenges (hitting 60 FPS harder)
- ‚ö†Ô∏è Less practical as ambient backgrounds (too intense)

**Top 4 Effect Candidates**:
1. **ASCII Fluid Dynamics** - Real fluid simulation (water/smoke/fire)
2. **Ray-Marched 3D Scenes** - Mountains, spheres, cityscapes with lighting
3. **Metaball Playground** - Interactive blobs that merge/split
4. **ASCII Art Morphing** - Shapes morph between forms (cat ‚Üí dog ‚Üí tree)

---

### Option 3: Enhanced Existing Patterns üîß‚ö°
**Refine and perfect what we have before adding new patterns**

**Advantages**:
- ‚úÖ Lower risk, faster delivery
- ‚úÖ Improves existing user experience
- ‚úÖ Good for polish/refinement phase

**Challenges**:
- ‚ö†Ô∏è Less exciting than new patterns
- ‚ö†Ô∏è May not attract new users
- ‚ö†Ô∏è Incremental rather than transformative

**Top 4 Enhancement Candidates**:
1. **Particle** - Connection lines ("constellation web")
2. **Life** - Interactive editing, multiple rule sets
3. **Maze** - Solving visualization, pathfinding
4. **Performance Profiling UI** - Real-time dashboard

---

---

## üöÄ Implementation Strategy: Hybrid Phased Approach

**Confirmed Direction**: Hybrid Strategy (Scenes + Advanced Effect)  
**Primary**: 5 Scene-Based Patterns  
**Secondary**: Metaball Playground (interactive liquid effect)  
**Bonus**: Minor enhancements to Particle and Life patterns

---

## üìÖ Implementation Timeline

### Phase 1: Foundation (2-3 weeks)

**Goal**: Establish architecture for scene-based rendering

#### 1.1 Architecture Enhancements
- [ ] **Scene Graph System**
  - Layer management (background, midground, foreground, UI)
  - Z-ordering for proper depth rendering
  - Per-layer update/render cycles
  
- [ ] **Sprite System**
  - Sprite class with position, animation frames, physics
  - SpriteManager for batch updates
  - Collision detection helpers
  
- [ ] **Enhanced Particle System**
  - Emitter patterns (point, line, area)
  - Force fields (gravity, wind, vortex)
  - Particle pooling for performance
  
- [ ] **Dependencies**
  - Add `simplex-noise` (4.0.3) for natural motion
  - Add `fast-simplex-noise` if performance requires

#### 1.2 First Scene: Ocean Beach (Difficulty: 7/10)

**Why First**: Validates new architecture, easier than Aquarium, universally appealing

**Animated Elements**:
- üåä Rolling waves with foam (Perlin noise)
- ‚òÅÔ∏è Drifting clouds (sprite-based)
- üê¶ Seagulls (parabolic flight paths)
- ‚ú® Sun sparkles (particle system)
- üë£ Fading footprints (click interaction)

**Technical Approach**:
- **Background layer**: Sky gradient (static)
- **Midground layer**: Ocean waves (1D Perlin noise, animated)
- **Foreground layer**: Beach sand, footprints (interactive)
- **Sprite layer**: Gulls, clouds (animated sprites)
- **Particle layer**: Sparkles (random blinking)

**Mouse Interaction**:
- Click on sand ‚Üí Create fading footprints
- Click in sky ‚Üí Gulls flock toward cursor
- Hover over water ‚Üí Intensify sparkles

**Performance Target**: 4% CPU, 60 FPS steady

**Characters**:
- Water: `~`, `-`, `_`, `‚âà` (with foam: `‚ó¶`, `‚àò`, `¬∞`, `¬∑`)
- Sky: Gradient from deep blue to light cyan
- Sand: `.`, `‚àô`, `¬∑`, `,`
- Gulls: `>`, `v`, `<` (depending on direction)
- Sparkles: `*`, `‚ú¶`, `¬∑`

**Estimated Effort**: 12-15 hours

---

#### 1.3 Second Scene: Campfire (Difficulty: 7/10)

**Why Second**: Showcases particle effects, simpler than fish AI, great visual appeal

**Animated Elements**:
- üî• Flickering flames (noise-based shapes)
- üí® Drifting smoke (particle system)
- ‚ú® Rising sparks (particle physics)
- üåü Radial light glow (color gradient)
- ü™µ Logs (interactive - click to add)

**Technical Approach**:
- **Background layer**: Dark gradient (night sky)
- **Foreground layer**: Logs, ground (static with occasional sparks)
- **Flame layer**: Noise-based flame shapes (animated)
- **Particle layer**: Sparks (rising with physics), smoke (drifting)
- **Lighting layer**: Radial color overlay (orange/yellow glow)

**Mouse Interaction**:
- Drag near fire ‚Üí Stoke flames (increase intensity, sparks)
- Click on fire ‚Üí Add log (visual + spark burst)
- Hover ‚Üí Heat distortion effect (character wobble)

**Performance Target**: 4% CPU, 60 FPS steady

**Characters**:
- Flames: `/`, `|`, `\`, `^`, `~`, `Y` (layered, orange/red/yellow)
- Smoke: `‚àô`, `¬∞`, `‚ó¶`, `o`, `O` (fading gray)
- Sparks: `*`, `‚ú¶`, `¬∑`, `¬∞` (bright white/yellow)
- Logs: `=`, `‚ïë`, `|` (brown/dark brown)

**Estimated Effort**: 10-12 hours

---

### Phase 2: Core Scenes (2-3 weeks)

#### 2.1 Third Scene: Aquarium (Difficulty: 9/10)

**Why Third**: Flagship interactive scene, most complex AI (boids), highest wow factor

**Animated Elements**:
- üêü Fish schools (boids algorithm - flocking behavior)
- üåø Swaying plants (sine-based animation)
- ü´ß Rising bubbles (particle system)
- üíé Treasure chest (occasional bubble burst)
- ü™® Rocks (static with occasional hiding fish)

**Technical Approach**:
- **Background layer**: Water gradient (blue/cyan, subtle shimmer)
- **Plant layer**: Swaying vegetation (sine curves, different phases)
- **Fish layer**: Boids (separation, alignment, cohesion rules)
- **Particle layer**: Bubbles (vertical with drift)
- **Decoration layer**: Rocks, chest (static but clickable)

**Boids Algorithm**:
```typescript
// For each fish:
1. Separation: Steer away from nearby fish (min distance: 3 units)
2. Alignment: Align velocity with nearby fish (radius: 8 units)
3. Cohesion: Move toward center of nearby fish (radius: 10 units)
4. Avoid walls: Steer away from screen edges
5. Mouse influence: Flee from cursor OR attract to cursor (toggle)
```

**Mouse Interaction**:
- Move cursor ‚Üí Fish flee or approach (toggle mode with spacebar)
- Click on fish ‚Üí Scatter burst (all fish flee radially)
- Click on chest ‚Üí Big bubble burst (15-20 bubbles)
- Hover on plant ‚Üí Gentle sway increase

**Performance Target**: 5-6% CPU (higher due to boids), 60 FPS

**Characters**:
- Fish: `><(('>`  or `><>` (depending on size)
- Plants: `|`, `/`, `\`, `Y`, `œà` (green gradient)
- Bubbles: `¬∞`, `o`, `O` (light blue/white)
- Rocks: `‚ñì`, `‚ñí`, `‚ñë` (gray)

**Estimated Effort**: 18-20 hours

---

#### 2.2 Fourth Scene: Night Sky with Aurora (Difficulty: 6/10)

**Why Fourth**: Showcases color gradients, simpler than Aquarium, peaceful

**Animated Elements**:
- ‚≠ê Twinkling stars (random brightness modulation)
- üåà Aurora ribbons (Perlin noise flow)
- üí´ Shooting stars (occasional particle streaks)
- üåå Nebula clouds (slow-drifting low-opacity layers)
- üåô Moon (optional, static with glow)

**Technical Approach**:
- **Background layer**: Deep space gradient (black to dark blue)
- **Nebula layer**: Slow-moving Perlin noise (low opacity)
- **Star layer**: Random twinkling (brightness modulation)
- **Aurora layer**: Flowing ribbons (Perlin noise curves, RGB blending)
- **Meteor layer**: Rare shooting stars (particle trails)

**Aurora Algorithm**:
```typescript
// For each column:
1. Calculate base height using Perlin noise (time-based)
2. Add sine wave variation for "ripple" effect
3. Calculate ribbon thickness (also noise-based)
4. Interpolate colors: green ‚Üí cyan ‚Üí purple ‚Üí pink
5. Apply intensity gradient (bright at edges, dim in center)
```

**Mouse Interaction**:
- Click anywhere ‚Üí Spawn meteor from cursor direction
- Hold click ‚Üí Create meteor shower (10-15 meteors)
- Drag ‚Üí Draw temporary constellation lines between stars

**Performance Target**: 3-4% CPU (mostly static), 60 FPS

**Characters**:
- Stars: `.`, `¬∑`, `*`, `‚ú¶`, `‚úß`, `‚òÖ` (by brightness)
- Aurora: `~`, `‚âà`, `‚àø`, `-`, `=` (green/cyan/purple gradient)
- Meteors: `*`, `-`, `¬∑` (white/yellow trail)
- Nebula: `:`, `.`, `¬∑` (very faint)

**Estimated Effort**: 12-14 hours

---

#### 2.3 Fifth Scene: Snowfall in Park (Difficulty: 7/10)

**Why Fifth**: Seasonal appeal, showcases accumulation logic, nostalgic

**Animated Elements**:
- ‚ùÑÔ∏è Falling snow (particle system with wind)
- üå≤ Swaying evergreens (gentle sine motion)
- üí® Wind gusts (affects snow trajectory)
- ‚ùÑÔ∏è Snow accumulation (ground builds up over time)
- üí° Streetlamp glow (static with radial light)
- üêøÔ∏è Small animals (optional - simple sprites)

**Technical Approach**:
- **Background layer**: Gray sky gradient (overcast)
- **Tree layer**: Evergreens (static with gentle sway)
- **Particle layer**: Falling snow (wind-affected physics)
- **Accumulation layer**: Ground snow (builds up, tracks depth)
- **Light layer**: Lamp glow (radial yellow gradient)
- **Sprite layer**: Animals (optional - wandering behavior)

**Accumulation Algorithm**:
```typescript
// For each ground cell:
1. Track snow depth (0-10 levels)
2. When snowflake lands, increment depth
3. Render based on depth:
   - 0: ground char (`.`, `,`)
   - 1-3: light dusting (`¬∑`, `‚àô`)
   - 4-6: medium (`*`, `‚ùÑ`)
   - 7-10: heavy (`‚ùÑ`, `*`, `‚ó¶`)
4. Occasional melt (depth slowly decreases)
```

**Wind System**:
```typescript
// Global wind:
windStrength = sin(time * 0.001) * 0.5 + cos(time * 0.0007) * 0.3
windDirection = sin(time * 0.0003) // -1 to 1
// Apply to each snowflake velocity
```

**Mouse Interaction**:
- Drag ‚Üí Create snow swirl/eddy following cursor
- Click ‚Üí Snowball burst (poof effect, 20 particles)
- Hover over tree ‚Üí Shake tree (snow falls off)

**Performance Target**: <4% CPU, 60 FPS

**Characters**:
- Snowflakes: `*`, `‚ùÑ`, `‚ú¶`, `¬∑`, `¬∞`, `‚àô`
- Trees: `Y`, `/`, `\`, `|`, `^` (green/dark green)
- Ground: `.`, `,`, `¬∑`, `‚àô` (white gradient by depth)
- Lamp: `‚óâ`, `‚óã` (yellow glow)

**Estimated Effort**: 14-16 hours

---

### Phase 3: Technical Showcase (1-2 weeks)

#### 3.1 Metaball Playground (Difficulty: 9/10)

**Why**: We already have metaball utilities (from LavaLamp), showcase groundbreaking effect

**Concept**: Interactive liquid mercury blobs that merge, split, and respond to physics

**Animated Elements**:
- üíß Multiple metaballs (3-8 balls)
- üåü Dynamic merging/splitting (threshold-based)
- üé® RGB color blending (balls have individual colors)
- ‚ö° Physics (gravity optional, mouse attraction/repulsion)
- ‚ú® Shimmer effect (metallic highlights)

**Technical Approach**:
- Use existing `src/utils/metaballs.ts` utilities
- Extend with:
  - Individual ball tracking (position, velocity, radius, color)
  - Influence field calculation (sum of all balls)
  - Threshold rendering (metaball isosurface)
  - Color blending (additive for overlaps)

**Metaball Physics**:
```typescript
// For each ball:
1. Apply gravity (optional)
2. Apply mouse force (attract or repel)
3. Ball-to-ball repulsion (prevent total merge)
4. Wall collision (bounce with damping)
5. Update position based on velocity
```

**Mouse Interaction**:
- **Drag ball**: Grab and move metaball
- **Click**: Create new metaball at cursor
- **Hold shift + move**: Repulsion mode (push balls away)
- **Spacebar**: Toggle gravity on/off

**Performance Target**: 5% CPU (metaball math is expensive), 60 FPS

**Characters**:
- High density: `‚ñà`, `‚ñì`, `@`, `#`
- Medium density: `‚ñí`, `‚ñë`, `‚óã`, `o`
- Low density: `¬∑`, `‚àô`, `.`
- Shimmer: `*`, `‚ú¶` (bright spots)

**Estimated Effort**: 12-14 hours (leveraging existing code)

---

### Phase 4: Polish & Release (1 week)

#### 4.1 Selective Enhancements

**Particle Pattern** - Connection Lines (2 hours):
- Draw thin lines (`-`, `|`, `/`, `\`, `¬∑`) between nearby particles
- Only connect if distance < threshold (configurable)
- Creates "constellation web" or "neural network" effect
- Mouse interaction: cursor becomes node in network

**Life Pattern** - Interactive Editing (2 hours):
- Click to toggle cells (alive/dead)
- Drag to draw patterns
- Keyboard shortcuts for common patterns (glider, pulsar, etc.)
- Step-through mode (space to advance one generation)

#### 4.2 Documentation & Media

- [ ] Update README with new scenes
- [ ] Record GIF demos for all 5 new scenes
- [ ] Update CHANGELOG.md
- [ ] Create `docs/planning/SCENE_ARCHITECTURE.md` (technical deep-dive)
- [ ] Update `docs/PROJECT_STATUS.md` with new metrics

#### 4.3 Testing & Optimization

- [ ] Performance profiling (all scenes at 60 FPS?)
- [ ] Memory leak checks (scenes running 10+ minutes)
- [ ] Small terminal testing (80x24 minimum)
- [ ] Theme compatibility (all 5 themes work with scenes)
- [ ] Mouse interaction testing (edge cases)

#### 4.4 Release Preparation

- [ ] Version bump to 0.3.0
- [ ] npm publish
- [ ] GitHub release with notes
- [ ] Social media announcements
- [ ] Community feedback collection

---

## üìã Detailed Scene Specifications

### üåä Ocean Beach Scene

**Rendering Layers** (bottom to top):
1. **Sky** (static gradient)
2. **Clouds** (slow drift, sprite-based)
3. **Sun** (static with sparkle particles)
4. **Ocean** (animated waves, Perlin noise)
5. **Beach** (static sand, interactive footprints)
6. **Gulls** (animated sprites)

**Wave Algorithm**:
```typescript
// For each column x:
baseHeight = height * 0.6 // Water line at 60% of screen
waveOffset = sin(x * 0.1 + time * 0.002) * 2 // Primary wave
waveOffset += sin(x * 0.3 + time * 0.005) * 1 // Secondary ripple
finalHeight = baseHeight + waveOffset

// Foam detection (wave crests):
if (waveOffset > 1.5) {
  spawnFoamParticle(x, finalHeight)
}
```

**Gull Behavior**:
```typescript
// Each gull:
state: 'gliding' | 'flocking' | 'diving'

// Gliding: Parabolic path
y = sin(time * 0.001 + phase) * amplitude + baseHeight
x += speed

// Flocking: Move toward flock center + mouse
if (mouseNearby) {
  steer toward mouse (limited turn rate)
}

// Diving: Occasional dive toward water
if (random() < 0.001) {
  state = 'diving'
  targetY = waterLevel
}
```

**Performance Budget**:
- Sky/sun: <1% CPU (mostly static)
- Waves: ~1.5% CPU (1D Perlin noise)
- Clouds: <0.5% CPU (4-6 sprites)
- Gulls: <0.5% CPU (3-5 sprites)
- Footprints: <0.5% CPU (decay tracking)
- **Total**: ~4% CPU

**Presets** (6 variations):
1. **Calm Morning**: Gentle waves, light blue, few gulls
2. **Midday Sun**: Strong sparkles, bright colors, active gulls
3. **Stormy**: Large waves, gray sky, fast gulls
4. **Sunset**: Orange/pink gradient, slow motion
5. **Night Beach**: Dark blue, moonlight sparkles, distant stars
6. **Tropical**: Turquoise water, palm trees (static), colorful fish jump

---

### üî• Campfire Scene

**Rendering Layers**:
1. **Night sky** (dark gradient, optional stars)
2. **Ground** (dark brown/gray, static)
3. **Logs** (brown, static or interactive)
4. **Flames** (animated, noise-based)
5. **Smoke** (particles, drifting up)
6. **Sparks** (particles, rising with physics)
7. **Light glow** (radial color overlay)

**Flame Algorithm**:
```typescript
// Flame shape as vertical curve:
for (let y = 0; y < flameHeight; y++) {
  let width = (flameHeight - y) / flameHeight * maxWidth
  width *= (1 + noise(time * 0.01, y * 0.1) * 0.3) // Flicker
  
  for (let x = centerX - width; x < centerX + width; x++) {
    intensity = 1 - (y / flameHeight) // Brighter at base
    intensity *= (1 + noise(time * 0.05, x * 0.1, y * 0.1) * 0.2)
    
    color = interpolateFireColor(intensity) // Yellow ‚Üí orange ‚Üí red
    char = getFlameChar(intensity) // '/', '|', '\', '^', '~'
  }
}
```

**Particle Systems**:

**Sparks**:
```typescript
spawn rate: 5-10 per frame (intensity-dependent)
initial velocity: upward (3-5 units/s) + random horizontal (-1 to 1)
acceleration: gravity (-9.8 downward), wind (slight horizontal)
lifetime: 1-2 seconds
color: bright white/yellow ‚Üí orange ‚Üí fade
characters: '*', '‚ú¶', '¬∑', '¬∞'
```

**Smoke**:
```typescript
spawn rate: 2-4 per frame
initial velocity: upward (1-2 units/s) + wind
acceleration: wind (horizontal), slight upward
lifetime: 3-5 seconds
color: white ‚Üí gray ‚Üí transparent
characters: '‚àô', '¬∞', '‚ó¶', 'o', 'O' (grow as they rise)
```

**Radial Light**:
```typescript
// For each cell:
distance = sqrt((x - fireX)¬≤ + (y - fireY)¬≤)
intensity = max(0, 1 - distance / lightRadius)
intensity *= fireIntensity // Linked to flame animation

// Color tint:
tint = lerp(baseColor, orange, intensity)
```

**Performance Budget**:
- Flames: ~1.5% CPU (noise-based shapes)
- Sparks: ~1% CPU (50-100 particles)
- Smoke: ~0.5% CPU (20-40 particles)
- Light glow: ~1% CPU (radial calculation)
- **Total**: ~4% CPU

**Presets**:
1. **Kindling**: Small flames, few sparks, building up
2. **Roaring Fire**: Large flames, many sparks, bright glow
3. **Dying Embers**: Low flames, occasional sparks, red glow
4. **Windy Night**: Flames blown sideways, smoke drifts
5. **Campfire Stories**: Moderate flames, flickering light, calm
6. **Bonfire**: Massive flames, intense sparks, wide glow

---

### üêü Aquarium Scene

**Rendering Layers**:
1. **Water background** (blue gradient with subtle shimmer)
2. **Rocks/decorations** (static, bottom layer)
3. **Plants** (animated, swaying)
4. **Fish** (boids, multiple schools)
5. **Bubbles** (particles, rising)
6. **Treasure chest** (static, clickable)

**Boids Algorithm** (Full Implementation):
```typescript
class Fish {
  position: Vector2
  velocity: Vector2
  color: Color
  size: number
  schoolId: number // Multiple schools
}

function updateFish(fish: Fish, neighbors: Fish[]) {
  // 1. Separation (avoid crowding)
  let separation = Vector2.zero()
  for (let other of neighbors.within(3)) {
    let diff = fish.position.subtract(other.position)
    separation = separation.add(diff.normalize())
  }
  separation = separation.multiply(separationWeight) // 1.5
  
  // 2. Alignment (match velocity)
  let alignment = Vector2.zero()
  for (let other of neighbors.within(8)) {
    alignment = alignment.add(other.velocity)
  }
  alignment = alignment.divide(neighbors.length).multiply(alignmentWeight) // 1.0
  
  // 3. Cohesion (move toward center)
  let cohesion = Vector2.zero()
  for (let other of neighbors.within(10)) {
    cohesion = cohesion.add(other.position)
  }
  cohesion = cohesion.divide(neighbors.length).subtract(fish.position).multiply(cohesionWeight) // 1.0
  
  // 4. Wall avoidance
  let avoidance = Vector2.zero()
  if (fish.position.x < margin) avoidance.x += (margin - fish.position.x)
  if (fish.position.x > width - margin) avoidance.x -= (fish.position.x - (width - margin))
  if (fish.position.y < margin) avoidance.y += (margin - fish.position.y)
  if (fish.position.y > height - margin) avoidance.y -= (fish.position.y - (height - margin))
  avoidance = avoidance.multiply(avoidanceWeight) // 2.0
  
  // 5. Mouse influence
  let mouseForce = Vector2.zero()
  if (mouseActive) {
    let diff = fish.position.subtract(mousePosition)
    let distance = diff.length()
    if (distance < mouseRadius) {
      let force = (mouseRadius - distance) / mouseRadius
      mouseForce = diff.normalize().multiply(force * mouseWeight) // Flee: 3.0, Attract: -2.0
    }
  }
  
  // Apply forces
  let acceleration = separation.add(alignment).add(cohesion).add(avoidance).add(mouseForce)
  fish.velocity = fish.velocity.add(acceleration).limit(maxSpeed) // 2-4 units/frame
  fish.position = fish.position.add(fish.velocity)
}
```

**Performance Optimization**:
- Spatial partitioning (grid-based) to reduce neighbor search from O(n¬≤) to O(n)
- Limit fish count (30-50 total, 3-4 schools)
- Update boids every 2-3 frames (still smooth at 20-30 Hz)

**Plant Animation**:
```typescript
// Each plant:
baseX = plantPosition.x
for (let segment = 0; segment < height; segment++) {
  let sway = sin(time * plantSpeed + segment * 0.2) * swayAmount
  let x = baseX + sway * (segment / height) // More sway at top
  let y = plantPosition.y - segment
  drawChar(x, y, plantChar, plantColor)
}
```

**Performance Budget**:
- Boids (40 fish): ~2.5% CPU (with spatial partitioning)
- Plants (8-12): ~0.5% CPU (sine calculations)
- Bubbles (20-30): ~0.5% CPU (simple physics)
- Water shimmer: ~0.5% CPU (subtle noise)
- **Total**: ~4-5% CPU

**Presets**:
1. **Tropical Reef**: Colorful fish, many plants, bright water
2. **Deep Sea**: Dark blue, bioluminescent fish, slow movement
3. **Goldfish Bowl**: Few large goldfish, simple plants, clear water
4. **Piranha Tank**: Fast red fish, aggressive flocking, dark water
5. **Koi Pond**: Large koi (4-5), lily pads, serene
6. **Neon Tetras**: Many small bright fish, dense plants, dark bg

---

### üåå Night Sky with Aurora

**Rendering Layers**:
1. **Deep space** (black to dark blue gradient)
2. **Nebula** (slow-drifting Perlin noise, very faint)
3. **Stars** (background, static with twinkling)
4. **Aurora** (flowing ribbons, animated)
5. **Meteors** (rare particle streaks)
6. **Moon** (optional, static with glow)

**Aurora Algorithm** (Detailed):
```typescript
// For each column x:
for (let x = 0; x < width; x++) {
  // Calculate base curve using Perlin noise
  let time1 = time * 0.0005
  let time2 = time * 0.0003
  
  // Primary wave
  let baseHeight = height * 0.4 + noise(x * 0.05 + time1, 0) * height * 0.2
  
  // Add ripple effect
  baseHeight += sin(x * 0.1 + time * 0.001) * 10
  
  // Calculate ribbon thickness
  let thickness = 5 + noise(x * 0.03 + time2, 1) * 8
  
  // Draw ribbon
  for (let y = baseHeight - thickness; y < baseHeight + thickness; y++) {
    // Distance from center of ribbon
    let distFromCenter = abs(y - baseHeight) / thickness
    
    // Intensity (bright at edges, dimmer in middle)
    let intensity = 1 - (distFromCenter * 0.7)
    intensity *= (0.7 + noise(x * 0.02, y * 0.02, time * 0.0001) * 0.3) // Shimmer
    
    // Color interpolation: green ‚Üí cyan ‚Üí purple ‚Üí pink
    let colorPosition = (x / width + time * 0.0002) % 1.0
    let color = interpolateAuroraColors(colorPosition, intensity)
    
    // Character selection
    let char = getAuroraChar(intensity) // '~', '‚âà', '‚àø', '-', '='
    
    drawChar(x, y, char, color)
  }
}
```

**Color Palette**:
```typescript
const auroraColors = [
  { r: 0, g: 255, b: 100 },   // Bright green
  { r: 0, g: 255, b: 200 },   // Cyan
  { r: 150, g: 0, b: 255 },   // Purple
  { r: 255, g: 0, b: 150 },   // Pink
]
// Interpolate smoothly between these
```

**Star Twinkling**:
```typescript
// Each star:
baseBrightness = random(0.3, 1.0)
twinkleSpeed = random(0.001, 0.005)
twinkleAmount = random(0.2, 0.5)

currentBrightness = baseBrightness + sin(time * twinkleSpeed + phase) * twinkleAmount
char = getStarChar(currentBrightness) // '.', '¬∑', '*', '‚ú¶', '‚úß', '‚òÖ'
```

**Meteor System**:
```typescript
// Spawn rate: 0.1% per frame (rare)
// When spawned:
startPosition = { x: random(0, width), y: 0 }
velocity = { x: random(-3, 3), y: random(5, 10) }
trail = [] // Last 8-12 positions
lifetime = random(1, 2) seconds
color = white ‚Üí yellow ‚Üí fade

// Each frame:
position += velocity
trail.push(position)
if (trail.length > maxTrail) trail.shift()

// Render trail with fading
for (let i = 0; i < trail.length; i++) {
  let opacity = i / trail.length
  drawChar(trail[i], meteorChar, color with opacity)
}
```

**Performance Budget**:
- Aurora: ~1.5% CPU (Perlin noise + interpolation)
- Stars: ~0.5% CPU (twinkling modulation)
- Nebula: ~0.5% CPU (slow-moving noise)
- Meteors: <0.5% CPU (1-2 active at most)
- **Total**: ~3% CPU

**Presets**:
1. **Polar Lights**: Classic green aurora, many stars
2. **Cosmic Storm**: Purple/pink aurora, active meteors
3. **Silent Night**: Gentle cyan aurora, slow motion, peaceful
4. **Solar Storm**: Intense multi-color aurora, rapid movement
5. **Stargazer**: Minimal aurora, focus on twinkling stars
6. **Nebula Dreams**: Prominent nebula clouds, faint aurora

---

### ‚ùÑÔ∏è Snowfall in Park

**Rendering Layers**:
1. **Sky** (gray gradient, overcast)
2. **Background trees** (distant, static silhouettes)
3. **Foreground trees** (animated sway)
4. **Falling snow** (particles)
5. **Ground snow** (accumulated, building up)
6. **Lamp light** (radial glow)
7. **Animals** (optional sprites)

**Snow Particle System**:
```typescript
class Snowflake {
  position: Vector2
  velocity: Vector2
  size: number // 1-3 (small/medium/large)
  rotationPhase: number // For drift pattern
}

// Global wind
windStrength = sin(time * 0.0008) * 0.4 + cos(time * 0.0005) * 0.3
windDirection = sin(time * 0.0003) // -1 (left) to 1 (right)

// Each snowflake
function updateSnowflake(flake: Snowflake) {
  // Base falling speed (size-dependent)
  let fallSpeed = 0.5 + flake.size * 0.3
  
  // Add drift (side-to-side wobble)
  let drift = sin(time * 0.01 + flake.rotationPhase) * 0.5
  
  // Apply wind
  flake.velocity.x = drift + windDirection * windStrength
  flake.velocity.y = fallSpeed
  
  // Update position
  flake.position = flake.position.add(flake.velocity)
  
  // Check ground collision
  if (flake.position.y >= groundLevel) {
    accumulateSnow(flake.position.x)
    respawnSnowflake(flake) // Recycle at top
  }
}
```

**Snow Accumulation**:
```typescript
// Ground array
groundSnowDepth = new Array(width).fill(0) // 0-10 levels

function accumulateSnow(x: number) {
  if (groundSnowDepth[x] < maxDepth) {
    groundSnowDepth[x] += 1
    
    // Spread to neighbors (simulate settling)
    if (groundSnowDepth[x] > groundSnowDepth[x-1] + 2) {
      groundSnowDepth[x-1] += 1
      groundSnowDepth[x] -= 1
    }
    if (groundSnowDepth[x] > groundSnowDepth[x+1] + 2) {
      groundSnowDepth[x+1] += 1
      groundSnowDepth[x] -= 1
    }
  }
}

function renderGround() {
  for (let x = 0; x < width; x++) {
    let depth = groundSnowDepth[x]
    let char = getSnowDepthChar(depth)
    let color = getSnowDepthColor(depth)
    drawChar(x, groundLevel, char, color)
  }
}

// Slow melt (optional)
// Every 10 seconds, reduce depth by 1 (if above 0)
```

**Tree Sway**:
```typescript
// Each tree:
for (let segment = 0; segment < treeHeight; segment++) {
  let sway = sin(time * 0.001 + segment * 0.1) * swayAmount * windStrength
  let x = treeX + sway * (segment / treeHeight) // More sway at top
  let y = groundLevel - segment
  drawChar(x, y, treeChar, treeColor)
  
  // Snow on branches (if sway is low)
  if (abs(sway) < 0.5 && random() < 0.3) {
    drawChar(x, y, '‚ùÑ', white)
  }
}
```

**Performance Budget**:
- Snow particles (100-150): ~2% CPU
- Ground accumulation: ~0.5% CPU
- Trees (4-6): ~0.5% CPU
- Wind calculation: <0.5% CPU
- Lamp glow: ~0.5% CPU
- **Total**: ~4% CPU

**Presets**:
1. **First Snowfall**: Light, gentle, minimal accumulation
2. **Blizzard**: Heavy snow, strong wind, fast accumulation
3. **Winter Wonderland**: Medium snow, calm, deep accumulation
4. **Evening Snow**: Dark sky, lamp prominent, peaceful
5. **Frozen Park**: Minimal new snow, deep existing snow, cold blue tint
6. **Thaw**: Slow snowfall, melting accumulation, warmer colors

---

### üíß Metaball Playground

**Rendering Layers**:
1. **Background** (dark gradient or theme-based)
2. **Metaball field** (calculated isosurface)
3. **Shimmer highlights** (bright spots on surface)
4. **UI hints** (optional - controls overlay)

**Metaball Physics** (Detailed):
```typescript
// Extends existing src/utils/metaballs.ts

interface MetaballBlob {
  id: number
  position: Vector2
  velocity: Vector2
  radius: number
  mass: number
  color: Color
  grabbed: boolean // Mouse dragging
}

function updatePhysics(blobs: MetaballBlob[], deltaTime: number, mousePos?: Point) {
  for (let blob of blobs) {
    if (blob.grabbed) {
      // Being dragged by mouse
      blob.position = mousePos
      blob.velocity = { x: 0, y: 0 }
      continue
    }
    
    // 1. Gravity (if enabled)
    if (gravityEnabled) {
      blob.velocity.y += GRAVITY * deltaTime
    }
    
    // 2. Mouse force (attract or repel)
    if (mousePos) {
      let direction = mousePos.subtract(blob.position)
      let distance = direction.length()
      if (distance < MOUSE_INFLUENCE_RADIUS) {
        let force = MOUSE_FORCE / (distance * distance)
        blob.velocity = blob.velocity.add(direction.normalize().multiply(force))
      }
    }
    
    // 3. Ball-to-ball repulsion (prevent total merge)
    for (let other of blobs) {
      if (other.id === blob.id) continue
      let direction = blob.position.subtract(other.position)
      let distance = direction.length()
      let minDistance = (blob.radius + other.radius) * 0.3
      if (distance < minDistance) {
        let force = REPULSION_FORCE * (minDistance - distance)
        blob.velocity = blob.velocity.add(direction.normalize().multiply(force))
      }
    }
    
    // 4. Wall collision (bounce with damping)
    if (blob.position.x - blob.radius < 0) {
      blob.velocity.x = abs(blob.velocity.x) * DAMPING
      blob.position.x = blob.radius
    }
    if (blob.position.x + blob.radius > width) {
      blob.velocity.x = -abs(blob.velocity.x) * DAMPING
      blob.position.x = width - blob.radius
    }
    if (blob.position.y - blob.radius < 0) {
      blob.velocity.y = abs(blob.velocity.y) * DAMPING
      blob.position.y = blob.radius
    }
    if (blob.position.y + blob.radius > height) {
      blob.velocity.y = -abs(blob.velocity.y) * DAMPING
      blob.position.y = height - blob.radius
    }
    
    // 5. Update position
    blob.position = blob.position.add(blob.velocity.multiply(deltaTime))
    
    // 6. Velocity damping (friction)
    blob.velocity = blob.velocity.multiply(FRICTION)
  }
}
```

**Rendering Algorithm**:
```typescript
// For each cell in buffer:
for (let y = 0; y < height; y++) {
  for (let x = 0; x < width; x++) {
    // Calculate metaball field strength
    let field = metaballField(x, y, blobs) // From existing utils
    
    if (field >= SURFACE_THRESHOLD) {
      // Inside metaball surface
      
      // Calculate blended color (weighted by field contribution)
      let color = blendMetaballColors(x, y, blobs)
      
      // Character selection by density
      let char = getMetaballChar(field)
      // field > 3.0: '‚ñà', '‚ñì', '@', '#'
      // field > 2.0: '‚ñí', '‚ñë', '‚óã', 'o'
      // field > 1.0: '¬∑', '‚àô', '.'
      
      // Add shimmer highlights (random, intensity-based)
      if (field > 2.5 && random() < 0.05) {
        char = '*' or '‚ú¶'
        color = brighten(color, 0.5)
      }
      
      buffer[y][x] = { char, color }
    }
  }
}
```

**Color Blending**:
```typescript
function blendMetaballColors(x: number, y: number, blobs: MetaballBlob[]): Color {
  let totalWeight = 0
  let blendedColor = { r: 0, g: 0, b: 0 }
  
  for (let blob of blobs) {
    let dx = x - blob.position.x
    let dy = y - blob.position.y
    let distSquared = dx * dx + dy * dy
    
    if (distSquared < 0.0001) {
      return blob.color // At center, use blob's color
    }
    
    // Weight by field contribution
    let weight = (blob.radius * blob.radius) / distSquared
    totalWeight += weight
    
    blendedColor.r += blob.color.r * weight
    blendedColor.g += blob.color.g * weight
    blendedColor.b += blob.color.b * weight
  }
  
  // Normalize
  if (totalWeight > 0) {
    blendedColor.r = Math.round(blendedColor.r / totalWeight)
    blendedColor.g = Math.round(blendedColor.g / totalWeight)
    blendedColor.b = Math.round(blendedColor.b / totalWeight)
  }
  
  return blendedColor
}
```

**Mouse Interaction**:
- **Click**: Create new metaball at cursor (up to max count)
- **Drag blob**: Grab nearest blob, move with cursor
- **Shift + move**: Repulsion mode (push blobs away)
- **Spacebar**: Toggle gravity on/off
- **Delete key**: Remove nearest blob (min 2 blobs)
- **R key**: Reset to preset initial state

**Performance Budget**:
- Metaball field calculation: ~3% CPU (O(n*width*height), but n is small)
- Physics updates: ~1% CPU (O(n¬≤), but n < 10)
- Color blending: ~0.5% CPU
- Shimmer effects: ~0.5% CPU
- **Total**: ~5% CPU

**Presets** (6 variations):
1. **Liquid Mercury**: 4 silver/chrome blobs, no gravity, high bounce
2. **Lava Blobs**: 5 orange/red blobs, gravity enabled, slow movement
3. **RGB Fusion**: 3 large blobs (red, green, blue), color blending showcase
4. **Plasma Orbs**: 6 small purple/pink blobs, repulsion mode, fast movement
5. **Water Droplets**: 8 small cyan blobs, gravity, coalescence
6. **Chaotic**: 10 multi-colored blobs, strong forces, high interaction

**Character Palette by Density**:
```typescript
const METABALL_CHARS = {
  veryHigh: ['‚ñà', '‚ñì', '‚ñì'],  // field > 3.0
  high: ['‚ñí', '‚ñí', '‚ñë'],      // field > 2.0
  medium: ['‚óã', 'o', '‚ó¶'],    // field > 1.5
  low: ['¬∞', '‚àô', '¬∑'],       // field > 1.0
  shimmer: ['*', '‚ú¶', '‚óá']    // highlights
}
```

**Constants**:
```typescript
const SURFACE_THRESHOLD = 1.0  // Metaball isosurface threshold
const MOUSE_INFLUENCE_RADIUS = 20  // Mouse effect range
const MOUSE_FORCE = 5.0  // Attraction/repulsion strength
const REPULSION_FORCE = 2.0  // Ball-to-ball repulsion
const GRAVITY = 9.8  // Downward acceleration
const DAMPING = 0.7  // Wall bounce energy loss
const FRICTION = 0.98  // Velocity damping per frame
const MAX_BLOBS = 10  // Maximum metaballs
const MIN_BLOBS = 2  // Minimum metaballs
```

---

## üíª Technical Architecture

### Scene Graph System

```typescript
interface SceneLayer {
  name: string
  zIndex: number
  visible: boolean
  update(deltaTime: number): void
  render(buffer: Cell[][]): void
}

class SceneGraph {
  private layers: Map<string, SceneLayer> = new Map()
  
  addLayer(layer: SceneLayer): void
  removeLayer(name: string): void
  getLayer(name: string): SceneLayer | undefined
  
  update(deltaTime: number): void {
    // Update all layers
    for (let layer of this.layers.values()) {
      if (layer.visible) {
        layer.update(deltaTime)
      }
    }
  }
  
  render(buffer: Cell[][]): void {
    // Sort by z-index
    let sorted = Array.from(this.layers.values()).sort((a, b) => a.zIndex - b.zIndex)
    
    // Render bottom to top
    for (let layer of sorted) {
      if (layer.visible) {
        layer.render(buffer)
      }
    }
  }
}
```

### Sprite System

```typescript
interface Sprite {
  position: Vector2
  velocity: Vector2
  frames: string[][] // Animation frames
  currentFrame: number
  frameDuration: number // ms per frame
  color: Color
  scale: number
}

class SpriteManager {
  private sprites: Sprite[] = []
  
  addSprite(sprite: Sprite): void
  removeSprite(sprite: Sprite): void
  
  update(deltaTime: number): void {
    for (let sprite of this.sprites) {
      // Update animation
      sprite.currentFrame = (sprite.currentFrame + 1) % sprite.frames.length
      
      // Update physics
      sprite.position = sprite.position.add(sprite.velocity.multiply(deltaTime))
    }
  }
  
  render(buffer: Cell[][]): void {
    for (let sprite of this.sprites) {
      let frame = sprite.frames[sprite.currentFrame]
      // Render frame at sprite.position
    }
  }
}
```

### Enhanced Particle System

```typescript
interface ParticleEmitter {
  position: Vector2
  emissionRate: number // particles per second
  particleLife: number // seconds
  initialVelocity: Vector2Range
  acceleration: Vector2 // gravity, wind, etc.
  color: ColorRange
  characters: string[]
  
  emit(): Particle[]
}

class ParticleSystem {
  private emitters: ParticleEmitter[] = []
  private particles: Particle[] = []
  private maxParticles: number = 1000
  
  addEmitter(emitter: ParticleEmitter): void
  removeEmitter(emitter: ParticleEmitter): void
  
  update(deltaTime: number): void {
    // Emit new particles
    for (let emitter of this.emitters) {
      let count = emitter.emissionRate * deltaTime
      for (let i = 0; i < count; i++) {
        if (this.particles.length < this.maxParticles) {
          this.particles.push(emitter.emit())
        }
      }
    }
    
    // Update existing particles
    for (let particle of this.particles) {
      particle.velocity = particle.velocity.add(particle.acceleration.multiply(deltaTime))
      particle.position = particle.position.add(particle.velocity.multiply(deltaTime))
      particle.life -= deltaTime
    }
    
    // Remove dead particles
    this.particles = this.particles.filter(p => p.life > 0)
  }
  
  render(buffer: Cell[][]): void {
    for (let particle of this.particles) {
      // Render particle at position with character/color
    }
  }
}
```

---

## üìä Success Metrics

### Performance Targets
- **CPU Usage**: 4-6% per scene (variable by complexity, at 60 FPS)
  - Ocean Beach: 4% target
  - Campfire: 4% target
  - Aquarium: 5-6% target (boids are expensive)
  - Night Sky: 3-4% target (mostly static)
  - Snowfall: 4% target
  - Metaball Playground: 5% target
- **Memory**: <60 MB total (including Node.js overhead)
- **Frame Rate**: 60 FPS steady (with <5% dropped frames)
- **Startup Time**: <500ms to first render

### Quality Targets
- **Visual Appeal**: 9/10 minimum (subjective, user feedback)
- **Ambient Suitability**: Scenes work as IDE backgrounds without distraction
- **Interactivity**: All mouse interactions feel responsive (<50ms latency)
- **Theme Compatibility**: All scenes work with all 5 themes

### Technical Targets
- **Test Coverage**: 90%+ (up from 92.35%)
- **Code Quality**: No new TypeScript errors, ESLint clean
- **Documentation**: Complete technical specs for each scene
- **Bundle Size**: <2 MB total (acceptable for terminal app)

---

## üóìÔ∏è Timeline Estimate

**Total Estimated Time**: 8-10 weeks (part-time development)

| Phase | Duration | Deliverables |
|-------|----------|--------------|
| **Phase 1: Foundation** | 2-3 weeks | Scene graph, sprite system, Ocean Beach, Campfire |
| **Phase 2: Core Scenes** | 2-3 weeks | Aquarium, Night Sky, Snowfall |
| **Phase 3: Technical Showcase** | 1-2 weeks | Metaball Playground |
| **Phase 4: Polish** | 1 week | Enhancements, docs, testing, release |

**Milestones**:
- Week 3: Ocean Beach complete (validates architecture)
- Week 5: Campfire + Aquarium complete (flagship scenes)
- Week 7: All 5 scenes complete
- Week 9: Metaball + enhancements complete
- Week 10: Release v0.3.0

---

## ‚úÖ Finalized Decisions (Nov 5, 2025)

All 10 key questions have been resolved:

| Question | Decision | Rationale |
|----------|----------|-----------|
| **1. Primary Direction** | **D) Hybrid** - All 5 scenes + Metaball Playground | Transformative change, unique differentiator |
| **2. Scope** | **A) All 5 scenes** + Metaballs (8-10 weeks) | Full ambitious scope, winter timing perfect |
| **3. Priority Order** | **Approved** - Beach ‚Üí Campfire ‚Üí Aquarium ‚Üí Night Sky ‚Üí Snowfall | Validates architecture early, saves boids complexity for mid-phase |
| **4. Advanced Effect** | **A) Metaball Playground** | Leverages existing `metaballs.ts`, achievable performance |
| **5. Architecture** | **A) Build architecture first** | SceneGraph/SpriteManager upfront investment pays off |
| **6. Dependencies** | **A) Add simplex-noise** | Industry standard for organic motion, better than our noise |
| **7. Performance** | **C) Variable targets** - 4-6% per scene | Beach 4%, Campfire 4%, Aquarium 5-6%, Night Sky 3-4%, Snowfall 4% |
| **8. Seasonal Timing** | **A) Include Snowfall in v0.3.0** | November timing perfect for winter scenes |
| **9. Wildlife** | **B) Minimal** - Fish + seagulls only | Focus on environments, key creatures where they define the scene |
| **10. Customization** | **A) Presets only** (6 per scene) | Keep v0.3.0 simple, parameters in v0.4.0 |

**Status**: ‚úÖ All decisions finalized, ready to begin Phase 1

---

## üìö Additional Resources

### Research Citations
- Perplexity research on cutting-edge terminal graphics (Nov 5, 2025)
- Perplexity research on scene-based animation techniques (Nov 5, 2025)
- Existing pattern audit: `docs/planning/enhancement-proposals/PATTERN_AUDIT.md`

### Related Documents
- `docs/ARCHITECTURE.md` - Current technical architecture
- `docs/planning/enhancement-proposals/FIREWORKS.md` - Example of phased enhancement
- `docs/planning/enhancement-proposals/VISUAL_MEDIA.md` - GIF creation process
- `docs/core/CONTRIBUTING.md` - Pattern development guide

### External Inspiration
- **blessed-contrib**: Scene graph approach for terminal dashboards
- **terminal-kit**: Performance optimization techniques
- **aemkei/3d-ascii**: 3D rendering in terminals
- **Boids algorithm**: Craig Reynolds, 1986

---

## üöÄ Next Steps

### Immediate (This Week)

**Step 1: Add Dependencies** ‚öôÔ∏è
```bash
npm install simplex-noise@4.0.3
npm install --save-dev @types/simplex-noise
```

**Step 2: Architecture Foundation** üèóÔ∏è
- Create `src/engine/SceneGraph.ts` - Layer management system
- Create `src/engine/SpriteManager.ts` - Animated sprite system  
- Create `src/engine/ParticleSystem.ts` - Enhanced particle emitters
- Add Vector2 utilities to `src/utils/math.ts`

**Step 3: Begin Ocean Beach Pattern** üåä
- Create `src/patterns/OceanBeachPattern.ts`
- Implement wave algorithm (Perlin/simplex noise)
- Add sky gradient background
- Basic rendering test

### Phase 1 Goals (Weeks 1-3)
- ‚úÖ Architecture complete and tested
- ‚úÖ Ocean Beach fully functional with 6 presets
- ‚úÖ Campfire fully functional with 6 presets
- ‚úÖ Tests for Scene Graph, Sprite, Particle systems
- ‚úÖ Performance validation (<4% CPU per scene)

### Phase 2 Goals (Weeks 4-6)
- ‚úÖ Aquarium with boids algorithm
- ‚úÖ Night Sky with aurora
- ‚úÖ Snowfall with accumulation
- ‚úÖ All 5 scenes tested and optimized

### Phase 3 Goals (Weeks 7-8)
- ‚úÖ Metaball Playground interactive pattern
- ‚úÖ Particle pattern enhancements (connection lines)
- ‚úÖ Life pattern interactivity

### Phase 4 Goals (Week 9-10)
- ‚úÖ Documentation complete
- ‚úÖ GIF demos recorded
- ‚úÖ Tests at 90%+ coverage
- ‚úÖ v0.3.0 published to npm

---

**Status**: ‚úÖ Finalized & Approved - Ready for Implementation  
**Version**: 2.0 (Finalized)  
**Last Updated**: November 5, 2025  
**Approval Date**: November 5, 2025  
**Target Release**: Mid-January 2026

---

**Let's make v0.3.0 LEGENDARY!** üåäüî•üêüüåå‚ùÑÔ∏è‚ú®
